@page "/board"

@rendermode RenderMode.InteractiveAuto

@attribute [Route(Shared.Routes.Blazor.Views.BoardView)]

@inject GameState Game

<div id="board-gird">
  @for (int y = 0; y < BoardDimensions.Y; ++y)
  {
    <div id="row-@y" class="board-row">
      @for (int x = 0; x < BoardDimensions.X; ++x)
      {
        int tmp_x = x, tmp_y = y;
        <div id="column-@x" class="board-column @GetCellColor(x, y)">
          <button class="chess-piece" @onclick="() => OnSquareClicked(tmp_x, tmp_y)">
          @if (BoardPieces.GetPiece(x, y) is not EmptyPiece)
          {
              <img src="img/pieces/@GetPieceGraphic(x, y)"
                   class="chess-piece @(selectedPiece == BoardPieces.GetPiece(x, y) ? "selected" : "")" />
          }
          </button>
        </div>
      }
    </div>
  }
</div>

@code {
  IList<IList<PieceBase>> BoardPieces = new List<IList<PieceBase>>();
  int[,] highlights = new int[8,8];

  PieceBase? selectedPiece = null;

  (int X, int Y) BoardDimensions = (8, 8);

  [Parameter]
  public required Sets Set { get; set; }

  //NOTE: FEN meaning:                           Board state,whos move,castiling,En passant, Halfmove clock,Fullmove number
  private string _boardLayout = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

  protected override async Task OnInitializedAsync()
  {
    if (Game.CurrentFEN is not "")
      _boardLayout = Game.CurrentFEN;

    BoardPieces = BoardHelpers.FENToBoard(_boardLayout);

    await InvokeAsync(() => StateHasChanged());
  }

  async Task OnSquareClicked(int x, int y)
  {
    PieceBase piece = BoardPieces.GetPiece(x, y);

    if (selectedPiece is not null && SquareContainsMove(x, y)) {
      await MakeMove(x, y);
      return;
    }

    //NOTE: check if select and piece is same object [                    ]
    if (piece is EmptyPiece || Object.ReferenceEquals(selectedPiece, piece)) {
      highlights = new int[8,8];
      selectedPiece = null;
      await InvokeAsync(() => StateHasChanged());
      return;
    }

    highlights = piece.GetValidMoves(BoardPieces);
    selectedPiece = piece;

    await InvokeAsync(() => StateHasChanged());
  }

  string GetPieceGraphic(int x, int y)
  {
    PieceBase piece = BoardPieces.GetPiece(x, y);
    return BoardHelpers.GetPieceString(piece);
  }

  bool SquareContainsMove(int x, int y)
  {
    return highlights[x, y] != 0;
  }

  string GetCellColor(int x, int y)
  {
    return highlights[x,y] switch {
      1 => "color-green",
      2 => "color-red",
      //NOTE: all even (index based) cells must be white, all un-even must be black
      _ => (x + y) % 2 == 0 ? "color-white" : "color-black",
    };
  }

  async Task MakeMove(int x, int y)
  {
    if (selectedPiece is null)
      return;

    int[] selectedPiecePosition = selectedPiece.Position;
    BoardPieces[selectedPiecePosition[1]][selectedPiecePosition[0]] = new EmptyPiece();
    BoardPieces[y][x] = selectedPiece;

    selectedPiece.Position = [x, y];

    highlights = BoardPieces[selectedPiecePosition[1]][selectedPiecePosition[0]].GetValidMoves(BoardPieces);

    selectedPiece.MadeMove();
    selectedPiece = null;
    await InvokeAsync(() => StateHasChanged());
    return;
  }
}